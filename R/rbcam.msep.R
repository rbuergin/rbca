#' Mean Squared Error of Prediction for Holdout Profiles
#'
#' Computes the mean squared error (MSEP) of prediction for holdout profiles using
#' a list of conjoint analysis models fitted with \code{\link{rbcam}}.
#' This is useful to evaluate the out-of-sample performance of conjoint models.
#'
#' @param object.list A list of model objects of class 'rbcam', typically
#'   generated by \code{rbcam}. If a single \code{rbcam} object is supplied,
#'   it will be coerced to a list internally.
#' @param newdata A \code{data.frame} containing the holdout profiles with the same structure
#'   as the data used for fitting, including the response variable. The dataset must contain
#'   all attribute variables, a level-1 identifier (if applicable), and the response variable
#'   used for fitting the original models.
#' @param level An integer indicating the level of the model to evaluate: \code{1}, \code{2},
#'   or \code{3}. Default is \code{3}.
#'
#' @return A named numeric vector of mean squared prediction errors for each model in the list.
#'
#' @seealso \code{rbcam}, \code{rbcam.predict}
#'
#' @examples
#' data(tea)
#'
#' # Generate new data
#' tea.m.w1 <- rbcam(
#'   formula = rating ~ price + variety + kind + aroma,
#'   data = tea[tea$profile != "1", ],
#'  var.level.1 = "respondent",
#'   contrasts.factor = "contr.treatment")
#'
#' rbcam.msep(object.list = tea.m.w1, newdata = tea[tea$profile == "1", ])
#'
#' @export

rbcam.msep <- function(object.list, newdata, level = 3) {
  if (inherits(object.list, "rbcam")) object.list <- list(object.list)
  if (!all(sapply(object.list, function(x) inherits(x, "rbcam"))))
    stop("some elements of 'object.list' not of class 'rbcam'.")
  if (!is.data.frame(newdata)) stop("'newdata' must be a data.frame.")
  rval <- sapply(
    X = object.list,
    FUN = function(x) {
      response.name <- all.vars(terms(x$mlist.level.3))[attr(terms(x$mlist.level.3), "response")]
      if (!response.name %in% colnames(newdata)) stop(paste0("rating variable '", response.name, "' not found in 'newdata'."))
      fitted <- rbcam.predict(x, newdata = newdata, level = level)
      return(sum((fitted - newdata[, response.name])^2) / nrow(newdata))
    })
  if (!is.null(object.list)) names(rval) <- names(object.list)
  return(rval)
}
